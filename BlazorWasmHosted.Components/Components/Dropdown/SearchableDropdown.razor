@typeparam TItem
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.JSInterop
@implements IAsyncDisposable

<div class="position-relative" @ref="dropdownRef" @onclick:stopPropagation="true">
    <button type="button" 
            class="form-select text-start"
            style="cursor: pointer;"
            @onclick="ToggleDropdown"
            @onclick:stopPropagation="true"
            disabled="@Disabled">
        @GetDisplayText()
    </button>

    @if (IsOpen)
    {
        <div class="dropdown-menu show w-100 shadow" style="max-height: 300px; overflow: hidden;" @onclick:stopPropagation="true">
            <div class="p-2 border-bottom">
                <input type="text" 
                       class="form-control form-control-sm"
                       placeholder="@SearchPlaceholder"
                       @bind="searchText"
                       @bind:event="oninput"
                       @onkeydown="OnSearchKeyDown"
                       @ref="searchInputRef"
                       autocomplete="off" />
            </div>

            <div style="max-height: 250px; overflow-y: auto;">
                @if (AllowClear && SelectedItem != null)
                {
                    <button type="button"
                            class="dropdown-item text-danger"
                            @onclick="ClearSelection">
                        <i class="bi bi-x-circle me-2"></i>Clear selection
                    </button>
                    <div class="dropdown-divider"></div>
                }

                @if (FilteredItems.Any())
                {
                    @foreach (var item in FilteredItems)
                    {
                        var isSelected = SelectedItem?.Equals(item) ?? false;
                        var itemColor = GetItemColor(item);
                        <button type="button"
                                class="dropdown-item d-flex align-items-center @(isSelected ? "active" : "")"
                                @onclick="() => SelectItem(item)">
                            @if (!string.IsNullOrEmpty(itemColor))
                            {
                                <span class="rounded-circle me-2" 
                                      style="width: 16px; height: 16px; background-color: @itemColor; border: 1px solid rgba(0,0,0,0.1);"></span>
                            }
                            <span class="flex-grow-1 text-truncate">@GetItemText(item)</span>
                            @if (isSelected)
                            {
                                <i class="bi bi-check ms-2"></i>
                            }
                        </button>
                    }
                }
                else
                {
                    <div class="dropdown-item text-muted disabled">
                        No results found
                    </div>
                }
            </div>
        </div>
    }
</div>

@code {
    [Parameter] public TItem? SelectedItem { get; set; }
    [Parameter] public EventCallback<TItem> SelectedItemChanged { get; set; }
    [Parameter] public List<TItem> Items { get; set; } = new();
    [Parameter] public Func<TItem, string> ItemTextField { get; set; } = item => item?.ToString() ?? "";
    [Parameter] public Func<TItem, string>? ItemColorField { get; set; }
    [Parameter] public string Placeholder { get; set; } = "Select...";
    [Parameter] public string SearchPlaceholder { get; set; } = "Search...";
    [Parameter] public bool Disabled { get; set; }
    [Parameter] public bool AllowClear { get; set; } = false;

    [Inject] private IJSRuntime JSRuntime { get; set; } = default!;

    private bool IsOpen { get; set; }
    private string searchText = "";
    private ElementReference dropdownRef;
    private ElementReference searchInputRef;
    private DotNetObjectReference<SearchableDropdown<TItem>>? dotNetRef;
    private IJSObjectReference? jsModule;

    private IEnumerable<TItem> FilteredItems
    {
        get
        {
            if (string.IsNullOrWhiteSpace(searchText))
                return Items;

            return Items.Where(item =>
                ItemTextField(item).Contains(searchText, StringComparison.OrdinalIgnoreCase));
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                dotNetRef = DotNetObjectReference.Create(this);
                jsModule = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/dropdown.js");
            }
            catch { }
        }

        if (IsOpen && jsModule != null && dotNetRef != null)
        {
            try
            {
                await jsModule.InvokeVoidAsync("addClickOutsideListener", dropdownRef, dotNetRef);
            }
            catch { }
        }
        else if (!IsOpen && jsModule != null)
        {
            try
            {
                await jsModule.InvokeVoidAsync("removeClickOutsideListener");
            }
            catch { }
        }
    }

    [JSInvokable]
    public void CloseDropdown()
    {
        IsOpen = false;
        searchText = "";
        StateHasChanged();
    }

    private string GetDisplayText()
    {
        return SelectedItem != null ? ItemTextField(SelectedItem) : Placeholder;
    }

    private string GetItemText(TItem item)
    {
        return ItemTextField(item);
    }

    private string GetItemColor(TItem? item)
    {
        if (item == null || ItemColorField == null)
            return string.Empty;
        return ItemColorField(item);
    }

    private void ToggleDropdown()
    {
        if (Disabled) return;
        IsOpen = !IsOpen;
        searchText = "";
    }

    private async Task SelectItem(TItem item)
    {
        SelectedItem = item;
        await SelectedItemChanged.InvokeAsync(item);
        IsOpen = false;
        searchText = "";
    }

    private async Task ClearSelection()
    {
        SelectedItem = default;
        await SelectedItemChanged.InvokeAsync(default!);
        IsOpen = false;
        searchText = "";
    }

    private void OnSearchKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Escape")
        {
            IsOpen = false;
            searchText = "";
        }
    }

    public void Close()
    {
        IsOpen = false;
        searchText = "";
        StateHasChanged();
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            if (jsModule != null)
            {
                await jsModule.InvokeVoidAsync("removeClickOutsideListener");
                await jsModule.DisposeAsync();
            }
            dotNetRef?.Dispose();
        }
        catch { }
    }
}
